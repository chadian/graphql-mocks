## 1. Install Dependencies

Double-check that you already have installed `graphql-mocks` and
`graphql` dev dependencies. Also,
[`miragejs`](https://miragejs.com/docs/getting-started/installation/) will need
to be installed.

## 2. Create a GraphQL Handler and add Middlewares

The handler is used resolve GraphQL queries and provide the resulting JSON data.
This library provides `createQueryHandler` to make this task easier.

The first argument is the initial `resolverMap` which currently is an empty
object. Because we will be using auto resolvers we currently have not specified
any "static" resolvers.

The second argument is an object to provide `dependencies` and Resolver
Map `middlewares`.

<StepTwo/>

## 3. Add the `patchAutoResolvers` Middleware

Import `patchAutoResolvers`  and add it to the `middlewares`  array.

```js {2,9}
import { createQueryHandler } from 'graphql-mocks'
import { patchAutoResolvers } from 'graphql-mocks/mirage'

const resolverMap = {};

const handler = createQueryHandler(
  resolverMap,
  {
    middlewares: [patchAutoResolvers],
    dependencies: {},
  },
);
```

One thing to note about the `patch` prefix in `patchAutoResolvers`. That is
to illustrate that it is non-destructive to the original Resolver Map in the
sense that it will only add *auto resolvers* to fields that do not already have
a resolver defined. If our initial `resolverMap` had resolvers they would be
left in place.

## 4. Add Middleware Dependencies
The `dependencies` object is a key/value pair of dependencies. These are shared
across all the middleware are prevent from having to provide the same references
to each individual middleware. To avoid, having it error at us about missing
dependencies, let's go ahead and provide the dependencies it needs up front.

The first dependency it needs is `graphqlSchema`. This can be either an instance
of a `GraphQLSchema` or string formatted in GraphQL Schema Language. If you have
imported your schema using a tool it is probably already in one of those two
formats. For the purpose of this example we'll use a string formatted in GraphQL
Schema Language.

The second dependency is an instance of a `mirageServer`, or an instance of a
Mirage `Server`. We'll create one of those at the top, this might be something
you end up
[sharing](https://miragejs.com/docs/workflow-tips/#centralize-and-share-your-server-between-development-and-testing).

```js {5-24,33-34}
import { createQueryHandler } from 'graphql-mocks';
import { patchAutoResolvers } from 'graphql-mocks/mirage';
import { Server, Model } from 'miragejs';

const mirageServer = new Server({
  models: {
    movie: Model,
  }
});

const graphqlSchema = `
schema {
  query: Query
}

type Query {
  favoriteMovie: Movie!
  movies: [Movie!]!
}

type Movie {
  name: String!
}
`;

const resolverMap = {};

const handler = createQueryHandler(
  resolverMap,
  {
    middlewares: [patchAutoResolvers],
    dependencies: {
      graphqlSchema,
      mirageServer,
    },
  },
);
```

Note: The `graphqlSchema` and `mirageServer` are the required dependency names
and are looked up internally by these.

In this example we have created a root `Query` type with two fields
`favoriteMovie` and `movies`.  The `favouriteMovie` field should return a
non-null `Movie` type and the `movies` field would return a list of  `Movie`s.
The mirage server instance we created has a model definition for a `movie`
model.

## 5. Seeding our Mirage Server
We are almost ready to fire off a query but first we need something in our
server's db to return. Let's create a movie:

```js {11}
import { createQueryHandler } from 'graphql-mocks';
import { patchAutoResolvers } from 'graphql-mocks/mirage';
import { Server, Model } from 'miragejs';

const mirageServer = new Server({
  models: {
    movie: Model,
  }
});

mirageServer.schema.create('movie', { name: 'Inception' });

const graphqlSchema = `
schema {
  query: Query
}

type Query {
  favoriteMovie: Movie!
  movies: [Movie!]!
}

type Movie {
  name: String!
}
`;

const resolverMap = {};

const handler = createQueryHandler(
  resolverMap,
  {
    middlewares: [patchAutoResolvers],
    dependencies: {
      graphqlSchema,
      mirageServer,
    },
  },
);
```

## 6. Run the query!
Now with everything setup we can use the handler we created to perform a query
with `handler.query`. This returns a promise which we then `console.log` the results.

```js {41-53}
import { createQueryHandler } from 'graphql-mocks';
import { patchAutoResolvers } from 'graphql-mocks/mirage';
import { Server, Model } from 'miragejs';

const mirageServer = new Server({
  models: {
    movie: Model,
  }
});

mirageServer.schema.create('movie', { name: 'Inception' });

const graphqlSchema = `
schema {
  query: Query
}

type Query {
  favoriteMovie: Movie!
  movies: [Movie!]!
}

type Movie {
  name: String!
}
`;

const resolverMap = {};

const handler = createQueryHandler(
  resolverMap,
  {
    middlewares: [patchAutoResolvers],
    dependencies: {
      graphqlSchema,
      mirageServer,
    },
  },
);

handler.query(`
{
  favoriteMovie {
    name
  }
  movies {
    name
  }
}
`).then(
  (result) => console.log(JSON.stringify(result, null, 2)),
);
```

The `console.log` should output:
```json
{
  "data": {
    "favoriteMovie": {
      "name": "Inception"
    },
    "movies": [
      {
        "name": "Inception"
      }
    ]
  }
}
```

This result reflects what what is currently available in the mirage database.
What if _Inception_ wasn't the favorite movie though and you'd rather return
null? Or if we added two movies and `favoriteMovie` can since it can only return
one the auto resolver would throw an error. In these cases we can override the
auto resolver.

## 7. Overriding the Auto Resolver

If we revisit the previous example but this time added a second movie model, and
re-ran the query, we would receive an error.

```js
// Add two movies
mirageServer.schema.create('movie', { name: 'Inception' });
mirageServer.schema.create('movie', { name: 'Interstellar' });
```

The error would be similar to:
```
=== Mirage Auto Resolver Error [ROOT_TYPE] ===

An error occurred auto resolving ["Query", "favoriteMovie"]:
Tried to a coerce singular result but got an array of more than one result.
```

To fix this we can use the `MirageGraphQLMapper` utility class. It provides
several useful escape hatches to help out the auto-resolving process. In this
case we can add a _field filter_ to specify what the result for this field
should look like. The first argument will be an array of `results` of
auto-resolver has found so far, followed by the standard GraphQL resolver
arguments `parent`, `args`, `context`, `info` (usually `results`, `parent`, and
`args` are you all you need!). In this case we will just filter down the
existing result set.

```js
// Add MirageGraphQLMapper to our existing import
import { patchAutoResolvers, MirageGraphQLMapper } from 'graphql-mocks/mirage';

const mirageMapper = new MirageGraphQLMapper()
  .addFieldFilter(['Query', 'favoriteMovie'] (results, /*parent, args*/) => {
    return results.filter(movies => movie.name === 'Interstellar');
  });
```

Lastly, we add our new `mirageMapper` to the dependencies and our final example looks like this:

```js {13-16,42}
import { createQueryHandler } from 'graphql-mocks';
import { patchAutoResolvers, MirageGraphQLMapper } from 'graphql-mocks/mirage';
import { Server, Model } from 'miragejs';

const mirageServer = new Server({
  models: {
    movie: Model,
  }
});

mirageServer.schema.create('movie', { name: 'Inception' });

const mirageMapper = new MirageGraphQLMapper()
  .addFieldFilter(['Query', 'favoriteMovie'], (results, /*parent, args*/) => {
    return results.filter(movie => movie.name === 'Interstellar');
  });

const graphqlSchema = `
schema {
  query: Query
}

type Query {
  favoriteMovie: Movie!
  movies: [Movie!]!
}

type Movie {
  name: String!
}
`;

const resolverMap = {};

const handler = createQueryHandler(
  resolverMap,
  {
    middlewares: [patchAutoResolvers],
    dependencies: {
      graphqlSchema,
      mirageServer,
      mirageMapper,
    },
  },
);

handler.query(`
{
  favoriteMovie {
    name
  }
  movies {
    name
  }
}
`).then(
  (result) => console.log(JSON.stringify(result, null, 2))
);
```

Now if we run the query we should get:
```json
{
  "data": {
    "favoriteMovie": {
      "name": "Interstellar"
    },
    "movies": [
      {
        "name": "Inception"
      },
      {
        "name": "Interstellar"
      }
    ]
  }
}
```

_Interstellar_ was specified as our `favoriteMovie` in our `mirageMapper` and we
get back both for _Inception_ and _Interstellar_ for the `movies` field.
